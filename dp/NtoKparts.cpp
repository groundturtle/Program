/*
 * @Author: avert
 * @Date: 2022-03-08 00:31:07
 * @LastEditTime: 2022-04-29 10:23:50
 * @Description: 将一个整数n分为不重复的k份，求最多有几种不同的分法。其中数字不考虑顺序。
 */

/**
 * 这是典型的动态规划算法之一。
 * 1. 首先将n分给每一份1，进行保底，然后就可以进行随机分配。
 * 2. 剩下的n-j份，可以分成任意多份(1到j份)，并且要求其中的每一份都应该是不同的且不含0的。
 * 3. 如果从前面最开始一路算来，则填充的表格里已经有了数据，且前面填充表格时就是
 *    按照不得为0、(对同一个n/j)不得重复的原则进行的，因此可以直接采用前面表格中的数字。
 * 4. 具体实现为，先将对角线初始化为1(i=j必有唯一一种分配方式)，其他初始化为0，然后
 *    再从i=1, j=1开始遍历并填充表格。每一格的内容都为(i-j)行0到j列数值的总和。
 *    由此可知，当(i_1 - j_1) == (i_2 - j_2), 格子(i_2,j_2) = (i_1,j_1) + (i_1,j_1+1)  + (i_1,j_1+2) + ... + (i_1,j_2)
 *    而当(i_1-i_2) == 1时，就有(i_2, j_2) = (i_1, j_1) + (i_1-j_1, j_2)，其中(i_1-j_1)就等于(i_2-j_2)。
 */


// 注意数组的起始地点和终结地点，谨防越界；C++不检查数组越界，这是十分危险的。 
// 2022.03.08, 1:51

#include<iostream>

int main(int argc, char const *argv[])
{
    int n, k;
    std::cin>>n>>k;
    int dp[n+1][k+1];
    for (size_t i = 0; i < n+1; i++)
    {
        for (size_t j = 0; j < k+1; j++)
        {
            dp[i][j] = 0;
            if(i==j)
                dp[i][j] = 1;
        }
    }

    for (size_t i = 1; i < n+1; i++)
    {
        for (size_t j = 1; j < k+1; j++)
        {
            if (j<=i)
            {
                dp[i][j] = dp[i-j][j] + dp[i-1][j-1];
            }
            else break;   //后面已经全都等于初始化过的0了，就不用管了。
        }
    }

    std::cout<<dp[n][k];
    
    return 0;
}