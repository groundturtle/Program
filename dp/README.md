<!--
 * @Author: avert-win
 * @Date: 2022-04-28 23:44:32
 * @LastEditTime: 2022-04-29 14:58:50
 * @FilePath: \ProgramDaily\dp\README.md
 * @Description: 简介
-->

> 本目录下存储动态规划题型，部分题目有多解，可见其它文件夹或上网搜索。

动态规划的根本优点在于存储前面已经计算过的结果，留待后面直接使用，可以节省大量时间，通常将时间代价降到多项式级别。，

凡是可以用递归解决的问题，都可以用动态规划。

## 解题步骤

1. 判断是否可以用动态规划解决；
2. 写出状态表达式，尽量减少不必要的参数；
3. 确定各状态之间的关系，写出状态转移方程。
4. 开始制表（搜索前进并记录全部状态）

### 如何判断是否是动态规划问题？

1. 通常需要计算最大或最小值，或计算排列/概率的问题可以用动态规划求解；
2. 所有动态规划问题必须具有重叠子问题（重复的子问题），大部分动态规划问题具有最优子结构（最优解可有子问题最优解得来）。

### 如何确定状态表达式？

类似于寻找特征向量，只要找到必要的、最少的参数，这些参数组合起来能够唯一确定一个状态即可。

### 建立状态之间的关系

这是解决动态规划问题中最难的部分。可以**自顶向下**推导求解，也可以**自底向上**递进求解。
> 可以用递归的方式先自顶向下拆解问题，再转而利用动态规划的记忆方法解决重叠子问题。

## 自顶向下(Tabulation)和自底向上(Memoization)

For find the factorial of x, these two methods are shown below:
```cpp
int dp[max];

// top down.
int solve(int x)
{
    if(x==0)
        return 1;
    if(dp[x]!=-1)
        return dp[x];
    return (dp[x] = x*solve(x-1));
}

// bottom up.
int dp[0] = 1;
for(size_t i=1; i<=n; i++)
{
    dp[i] = dp[i-1]*i;
}
```


### 例题

#### 一、 过河卒问题：

1. 分解子问题：对于每个格点，可能有左上可达、左可达、上可达、不可达四种状态，其中前三种状态的可达路线有多种、与前面的步骤有关。真正的来源只有左、上两个。

2. 确定状态表达式：若将不可选来源记为0，则对于每一种状态，其可达的路线总数皆为可选来源的总数之和，表达式如下：
```cpp
dp[i][j] = dp[i-1][j] + dp[i][j-1] 
```

3. 此题较为简单，状态之间的关系和状态转移方程如上。
在实际过程中，由于左上两格的数不能随便清除，因此加个判断，若不可达则不加该数即可。

4. 开始计算、填表。

#### 二、 N to K parts

1. 分成子问题：先将N分出去K个1，剩下N-K个数(1)则可以任意分配，两者分配方案数相乘即为总数。这就是两个子问题。

2. 写出每个状态的表达式，其中dp为每份不为空的分配方案、bp为可空的分配方案，第一个索引为N、第二个索引为K，有：
$$
dp[N][K] = dp[K][K]*bp[N-K][K]
$$
根据以上方案，有
$$
bp[N][K] = dp[N][1] + dp[N][2] + ... + dp[N][K]
$$

3. 写出状态转移方程，观察表格，可以发现，
当: $(N_1 - K_1) == (N_2 - K_2)$, $dp[N_1][K_1]$ 和 $dp[N_2][K_2]$的加数来源于同一行，只是累加截止的列数不同，因此有公式：
$$
(N_2,K_2) = (N_1,K_1) + (N_1,K_1+1)  + (N_1,K_1+2) + ... + (N_1,K_2) 
$$
所以当: $(i_1-i_2) == 1$，有
$$
(i_2, j_2) = (i_1, j_1) + (i_1-j_1, j_2)
$$
由此，每个表格中数字的计算时间都降到了常数等级，且与前面的有直接关联。

4. 从头开始计算、填写表格(存储子问题解)即可。

## 动态规划类型：