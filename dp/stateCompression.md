<!--
 * @Author: avert-win
 * @Date: 2022-11-24 17:05:46
 * @LastEditTime: 2022-11-24 18:03:55
 * @FilePath: \ProgramDaily\dp\stateCompression.md
 * @Description: 简介
 * @LastEditors: avert-win
-->

#### 状态压缩

用更少的空间/数据量，来表示大量的状态，或是直接去除某些过程中产生的不必要的状态。

动态规划方法需要保存大量状态，因此经常与状态压缩一起使用。常用方法包括bitmask、数组投影。

若使用掩码进行状态压缩，选择数量较少的一个维度进行。原因是算法中需要用自增的方式枚举掩码，时间复杂度为指数级。

#### 示例一: 投影

在最简单的二维动态规划中，常用的状态转移方程是
```cpp
dp[i][j] = dp[i-1][j] + dp[i][j-1]
```
可以看到，二维dp数组中实际真正有用的只有左、上两个；并且由于向下投影后，有用的两个状态并不互相遮盖，因此可以将二维数组投影为一维数组`dp[]`。

每一个`dp[i-1][j]`在`dp[i][j]`处理完后立刻被抛弃，被`dp[i][j]`覆盖，作为下一次的左格；而在转行时，左侧是没有意义的，只需要`dp[0]`就能计算出当前的状态。

> 示例图：https://pic3.zhimg.com/80/v2-6921a9d2b263d37f6cf80e28b18f62a2_720w.webp


#### 示例二: bitmask/戴帽子

每个人有至少一顶帽子，世界上的帽子共h(h<=40)个款式，有n(n<=10)个人欲戴不同的帽子出门，求满足要求的戴帽子方法数。

用动态规划方法，必须找到一种方式表达子问题的状态。这个问题的当前状态应包括哪些人戴了帽子、被戴过的帽子有哪些，并且对于每个状态需要存储其对应的值（方法数）。用常规的二维数组`dp[][]`只能顺序处理，很难表示出全部可能性（如分配了最后两顶帽子而第一顶直至最后都无人戴上）。

考虑使用bitmask：
1. 选择最大不超过32或64的、状态只有两种的对象，此处可以选择人、使用int型；
2. 每一位用0表示未戴帽子，用1表示已经戴上帽子；
3. 每当新处理一个帽子`i`时，检查所有拥有该帽子的人`j`，若其在当前（新）状态下已被分配帽子，则当前状态的分配方案数应加上`i-1`时其未戴帽子ma，即sk第j位为0的方案数（`j`人戴`i`帽，新人新帽仅一个可能，所以原方案数乘1）；
另外，还要考虑帽子`i`最终不分配给任何人的情况，因此最后还要加上第`i-1`帽子与任意可能mask的组合。

注意以上，对于不可能的mask，如帽子数小于得到帽子的人数，通过合适的初始化就能解决（不可能的mask方案数为0），也不需要手动判断。
同样，对于不存在的帽子，在循环中加上的所有方案数都为0，因此最终也为0。

#### 示例三：bitmask/assignment problem

见源文件'jobAssignment.cpp'.