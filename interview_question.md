<!--
 * @Author: avert-win
 * @Date: 2022-11-22 19:40:21
 * @LastEditTime: 2022-11-22 21:20:12
 * @FilePath: \ProgramDaily\interview_question.md
 * @Description: 简介
 * @LastEditors: avert-win
-->

#### inline内联函数

内联函数，是一种以代码膨胀为代价、省去函数调用的栈帧开辟、结果返回等过程的时空消耗的方法。

- inline函数改变需要重新编译，因为是在任何需要调用该函数的地方复制一段代码（而不是从库中提取）。

- 是否内联完全取决于编译器，你所加上的关键字只是一种可有可无的建议；一般复杂的（如含循环、switch、递归等）函数不会内联。

- 内联能使编译器同时看到更多源代码信息，因此增加了优化的可能：两个最优局部的组合，可能具有更优的解法。

- inline函数使得重复包含头文件且通过编译成为可能，但也有可能导致未定义行为。

- 在类内实现（不是声明）的函数相当于在类外实现、加了`inline`关键字。

- 虚函数只有在确定应当使用哪个类的实现时可内联，因此由实际对象调用时可内联，而由指针或引用调用时不可内联。

#### 虚函数、多态和相关关键字

虚函数的通常应用场景是，使用一个基类的指针，指向特定的子类，并通过该指针调用函数。若子类未重新实现则默认使用基类的实现。

由于某些基类并不适合生成对象，因此定义**抽象类**：含有**纯虚函数**的类，该类规范接口、要求派生类提供必要的功能，但并不提供标准化（通用）方法，纯虚函数必须由子类自己实现。
> 一个子类可以将基类的纯虚函数再次定义为纯虚函数，因此该子类成为一个新的抽象类。

- `virtual`：声明虚函数，可在子类中（重新）实现。

- `final`(c++11)：用在类或者类的成员函数声明之后，使其不可继承（虚函数不可实例化）。

```c++
virtual void func();            // 虚函数声明，声明者必须实现
virtual void func1() = 0     // 纯虚函数声明，子类必须实现或再次声明为纯虚函数

virtual void func2() final;      // 不可继承函数
class oxygen final : public air{};      // 不可继承类
```

#### 宏和函数

宏定义代码块有时候可以充当没有返回值的函数，类似于内联函数，但没有类型检查、不能定义递归，且简单的代码替换可能造成一些意想不到的错误，如向`#define CAL(x) (x>0 ? x++:x)`传入`i++`，可能会造成未定义行为的出现、并且至少执行多次`i++`（你期望的只是一次）。

由于宏能省去函数调用的开销，嵌入式系统中经常用宏来代替函数。但代码膨胀和不安全的问题仍然存在。

> `assert()`就是一个宏，而非函数。

```c++
#define MACROFUNC(a,b) \
(\
    cout<<a>b ? a:b<<endl;\
)
```

_2022.11.12, 21.20pm_

------------------